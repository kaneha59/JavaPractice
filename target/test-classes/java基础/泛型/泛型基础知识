https://blog.csdn.net/s10461/article/details/53941091
类型擦除: https://www.cnblogs.com/wuqinglong/p/9456193.html
泛型，即“参数化类型”
在泛型使用过程中，*操作的数据类型被指定为一个参数*,(参数有形参实参之分)
这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

特性: 泛型只在编译阶段有效,编译后程序会将泛型的相关信息擦除.

泛型的应用:
    1. 泛型类
        可以实现对一组类的操作开放相同的接口,最经典的应用就是各种容器类,如List,Set,Map
    2. 泛型接口
        泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中
    3. 泛型方法
        在方法声明语句中单独声明泛型,要注意与泛型类区分开来!
            自己的区分技巧:
                泛型类中声明的泛型作用域是整个类,
                泛型方法中的泛型作用域是这个方法内.
                所以: 可以看作是局部变量和全局变量的区别
                    泛型方法需要单独声明泛型,如果仅仅用到类上的泛型,并不算是泛型方法
泛型通配符:
    ? ==>
    当你要定义一个方法,能够接收带泛型的入参时(比如Person<Student>,Person<Teacher>...),
    要怎么定义这个方法的入参呢?
        void test(Person<?> obj) {obj.showProfession();}
        *此处的?是类型实参,不是形参!*
        <?>就是泛型通配符,能够匹配所有的泛型.可以看作是所有类型的父类
泛型边界
    用于对传入的泛型类型实参进行上下边界的限制,比如实参只准传入Person类的子类
    <? super Apple> ==> 只能传入Apple的父类
        此时super是下边界,规定入参的类型下限是Apple类
    <? extends Student> ==> 只能传入Student的子类
        此时extends是上边界,规定入参的类型上限是Student类